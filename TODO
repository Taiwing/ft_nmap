- Try and fix ACK scan false 'positive' tests, meaning all
  the ports on which the scan result ends up randomly
  filtered where the original nmap always says unfiltered.
  It does not happen often (like 3/4 times on 1024 ports)
  but it still makes the result false and unreliable. The
  ACK scan should get an RST response for ending up in an
  unfiltered state, then sometimes it must not receive
  the RST response, or indeed any response at all. Either
  that or it gets an icmp packet out of the blue...
- Fix UDP scans missing close results. Like for the ACK
  scan, sometimes (actually most of the time for UDP),
  ft_nmap seems to be missing some responses, and so the
  UDP ports appear to be open|filtered when they should
  be closed. The scan just timeouts for no reason. This
  does not happen when the scan is done without speedup
  or with a low speedup and a limited amount of ports.
  Then this problem is probably has probably something
  to do with pcap_handler. It looks like it misses some
  responses when they come too close to one another.
  This is also certainly responsible for the missing
  unfiltered ACK scan results.
- The SYN scan looks reliable enough. Although it
  appears to fail some of the time too. It happened once
  on an 'intra.42.fr' scan (missing ariel3 port), and on
  'framasoft.org' it can happen too (saw it multiple
  times). This is also probably the same problem as for
  the ACK and UDP scans. The fact that it happens more
  and more as we 'go up' the scan list (because SYN is 0
  and UDP is 5 while ACK is in the middle, which is also
  how often this problem appears on each scan type), is
  probably be a hint to the root of the problem.
  UPDATE: It looks like each scan works as expected if
  executed individually (except maybe UDP, which is more
  complicated than the others as it takes at least 20min
  on a full 1024 ports scan for  the original nmap).
  The scans should probably be done consecutively,
  meaning that each scan type and their retries should
  be done on every port before the next scan type. This
  looks like the problem is caused by crossing the
  streams as the ghost busters would put it. If we try
  a lot of scans of different types at the same time,
  it just fails, probably because of firewall rules or
  of network overload.
  UPDATE2: For UDP and the closed/filtered states and
  for NULL/FIN/XMAS and the filtered state, the problem
  is that the linux kernel caps outgoing icmp packets to
  1 per second. This is why the UDP scan takes around 20
  minutes for on 1024 ports. There is no workaround for
  this. The only way is to scan once per second and limit
  retries to one. An other way to accelerate the process
  would be start with the ports where there are probes
  defined in nmap-payloads, as they have at least a
  chance to instantly return a UDP response (although,
  the time earned would be very small compared to the
  total time the scan would take).

- Rework the monothread logic so that ft_nmap is able to
  execute multiple scans at the same time. The solution
  might be to send multiple probes in a row in the alarm
  handler after the listening function has been called.
  This looks dirty, but it might be the only solution to
  pass the first test on the correction sheet, because
  with the original nmap I can justify a runtime of 20min
  for the UDP scan only not 8 hours. So ft_nmap, with
  every scan flag and no speedup should take around 20min
  too.

- Try to fix the fact that some probes are sent/received
  after the result has been printed. It's not a big deal
  so if there is no way to do that cleanly, just dont.
  UPDATE: It may be a bigger problem than expected. On
  some 1024-port scans, there are some open ports that
  are often missed at the end of the list (like rsync).
  This might be the cause.
  UPDATE2: Well it also leads to a segfault when a
  worker tries to send a probe after the host scan has
  ended. It rarely happens normally, but it almost
  always does on multiple target scans when we set a
  wait time in between probes. This is obviously a big
  problem now. This has to be fixed. Either by making it
  impossible to have task execute after the host scan is
  over (which I don't know how to do since they both
  happen in a worker task and also depend on the alarm
  handler) or by keeping track of the task associated
  with a host and delaying host printing while there are
  some tasks being executed. This looks like the easiest
  solution but maybe not the cleanest. This also will
  possibly change because the probe execution order will
  probably be modified.

- Do not use alarm_handler for setting timeouts. This is
  bad because sig_atomic_t variables are not atomic (yeah
  I know, wtf???). This means that the variables being
  changed inside the alarm_handler and across threads
  are not protected. They all should be replaced with
  _Atomic versions of their respective types, mostly int.
  Anyway, the retries/timeouts should be handled the new
  "timestamped tasks" system. This will delay tasks until
  their timestamp is passed. Replies and other tasks will
  have a NULL/zeroed-out timestamp for immediate execution
  but some send tasks will have this timestamp for wait
  time between retries. I guess each probe task will add
  its next one after it has sent its probe. The last retry
  will add a timeout reply task instead of a probe task.
  So these replies will need to have a timestamp too. This
  will work well for multithreading. But monothreaded mode
  is an other story. I think the "probe_all" tactic will
  be necessary. Basically probes will be sent in bursts in
  the alarm handler while the listen task is waiting for
  the replies (this also mean that the same filter will be
  used as for multithreaded mode). I still do not know how
  to handle the retries/timeout there, this will have be
  thought about.

- If multiple scans are given and ACK is one of them, do
  it first. This is because it can be used to guess wich
  ports are most likely to respond to the other scans. For
  example if every port is filtered except for 80, 443 and
  995 in the ACK scan, then the SYN scan can begin by
  probing these ports. This will minimize the problem of
  missing open ports at the end of the list. These are
  probably/possibly due to rate limiting on the host end.
  By being scan first these ports are less likely to be
  rate-limited.

- fix sendto 'invalid argument' error when probing port
  8080 on the local network host address (it works on
  localhost, it works on the wifi local address, but not
  on the default ethernet lan address)
  UPDATE: This does not happen when the drake simulator
  server is not lauched. It makes sense as it listens on
  the 8080 port.
- check other scan results too
- adapt the filter to ipv6 for the icmp part (also maybe
  clean the function/divide it because it's messy)
- when all this is done, check that the scan results are
  the same as the original nmap and that it does not
  take too much time to execute
- then stress-test the shit out of this program (really)

- Implement a "watch" mode for the heatmap option where
  ft_nmap would be continuously scanning the target
  ports on a regular interval. Updating the map as it
  eventually changes and notifying the user when they
  do occur.
